#+STARTUP: overview
#+TITLE: TediCreation's Emacs Configuration
#+CREATOR: Kanelis Elias
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;
[[./img/screen.png]]

* Environment variables
#+BEGIN_SRC emacs-lisp
  (setq tedi-org-directory "~/org/")
#+END_SRC
* Visit notes
#+BEGIN_SRC emacs-lisp
  (defun tedi:notes-visit ()
    "Visits the emacs config file"
    (interactive)
    (find-file (concat tedi-org-directory "notes.org")))
  (global-set-key (kbd "C-c n") 'tedi:notes-visit)
#+END_SRC
* Startup
** Garbage collection
   This fixed garbage collection, makes emacs start up faster.
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184 gc-cons-percentage 0.6)

  (defvar startup/file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)

  (defun startup/revert-file-name-handler-alist ()
    (setq file-name-handler-alist startup/file-name-handler-alist))

  (defun startup/reset-gc ()
    (setq gc-cons-threshold 16777216 gc-cons-percentage 0.1))

  (add-hook 'emacs-startup-hook 'startup/revert-file-name-handler-alist)
  (add-hook 'emacs-startup-hook 'startup/reset-gc)
#+END_SRC
** Customization file
   This save customizations somewhere other than the initialization file.
#+BEGIN_SRC emacs-lisp
   (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
   (when (file-exists-p custom-file)
   (load custom-file))
#+END_SRC
** Package manager
#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir (concat user-emacs-directory "packages")
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t))
    )

  (eval-and-compile
    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))

  (eval-when-compile
    (require 'package)
    (package-initialize)
    (add-to-list 'package-archives '("gnu"          . "https://elpa.gnu.org/packages/") t)
    (add-to-list 'package-archives '("melpa"        . "https://melpa.org/packages/") t)
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
    (add-to-list 'package-archives '("org"          . "https://orgmode.org/elpa/") t)

    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)
      (package-install 'diminish)
      (package-install 'quelpa)
      (package-install 'bind-key)
      )

    (setq use-package-always-ensure t)
    (setq use-package-expand-minimally t)

    (require 'use-package)
    )

  (require 'diminish)
  (require 'bind-key)
#+END_SRC
* Configuration
** Visiting the configuration
   Quickly visit the configuration file.
#+BEGIN_SRC emacs-lisp
  (defun tedi:config-visit ()
    "Visits the emacs config file"
    (interactive)
    (find-file (concat user-emacs-directory "config.org")))
  (global-set-key (kbd "C-c e") 'tedi:config-visit)
#+END_SRC
** Reloading the configuration
   Quickly reloads the configuration file.
#+BEGIN_SRC emacs-lisp
  (defun tedi:config-reload ()
    "Reloads the configuration file"
    (interactive)
    (org-babel-load-file (concat user-emacs-directory "config.org"))
    )
  (global-set-key (kbd "C-c r") 'tedi:config-reload)
#+END_SRC
* Basic Settings
These are setting that do not depend on packages and are built-in enhancements to the UI.
** Looks
*** Remove default startup screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC
*** Remove toolbar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC
*** Remove menubar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
#+END_SRC
*** Remove scrollbar
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
#+END_SRC
*** Show line numbers
#+BEGIN_SRC emacs-lisp
  (global-linum-mode t)
#+END_SRC
*** Make fullscreen
#+BEGIN_SRC emacs-lisp
  (set-frame-parameter nil 'fullscreen 'fullboth)
#+END_SRC
*** Fonts
#+BEGIN_SRC emacs-lisp
  (when (member "Source Code Pro" (font-family-list)) (set-frame-font "Source Code Pro-10" t t))
  (set-face-attribute 'default nil :height 100)     ;;Default font size %
#+END_SRC
*** Theme
#+BEGIN_SRC emacs-lisp
  (use-package monokai-theme
    :ensure t
    :config (load-theme 'monokai t))

  ;;(use-package zenburn-theme
  ;;  :ensure t
  ;;  :config (load-theme 'zenburn t))

  ;;(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
  ;;(load-theme 'tedi t)
#+END_SRC
*** Disable scratch message
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC
*** Do not blink cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC
*** Disable bell
This is annoying, remove this line if you like being visually reminded of events.
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC
*** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
*** Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC
*** Pretty symbols
Changes =lambda= to an actual symbol and a few others as well, only in the GUI version though.
#+BEGIN_SRC emacs-lisp
  (when window-system
    (use-package pretty-mode
      :ensure t
      :config
      (global-pretty-mode t)))
#+END_SRC
*** Visualize whitespace
#+BEGIN_SRC emacs-lisp
  (require 'whitespace)

  (setq whitespace-style '(face empty tabs tab-mark lines-tail trailing))

  ;;Visualize tabs as a pipe character - "|"
  (custom-set-faces '(whitespace-tab ((t (:foreground "#636363")))))
  (setq whitespace-display-mappings '((tab-mark 9 [124 9] [92 9]))) ; 124 is the ascii ID for '\|'

  (global-whitespace-mode t)
#+END_SRC
*** Change the name of 'list-buffers'
#+BEGIN_SRC emacs-lisp
  (defalias 'list-buffers 'ibuffer)
#+END_SRC
** Functionality
*** Move line up/down
#+BEGIN_SRC emacs-lisp
  (defun tedi:move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun tedi:move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (global-set-key [(meta up)]   'tedi:move-line-up)
  (global-set-key [(meta down)] 'tedi:move-line-down)
#+END_SRC
*** Go to line
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-g") 'goto-line)
#+END_SRC
*** Kill buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC
*** Multiplexing emacs and emacsclient
Opening a new file in the same emacs-session requires the use of emacsclient.
The emacs command can be itself wrapped to do the smarter job to open the file
if the session exists.
To start session you need to start-server. This snippet will create server in
first session of emacs. Add this to your emacs configuration file.
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
*** Disable backups and auto-saves
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+END_SRC
*** Smooth Scrolling
#+BEGIN_SRC emacs-lisp
;; Vertical Scroll
(setq scroll-step 1)
(setq scroll-margin 1)
(setq scroll-conservatively 101)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)
(setq auto-window-vscroll nil)
(setq fast-but-imprecise-scrolling nil)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-progressive-speed nil)
;; Horizontal Scroll
(setq hscroll-step 1)
(setq hscroll-margin 1)
#+END_SRC
*** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Async
Lets us use asynchronous processes wherever possible, pretty useful.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :init (dired-async-mode 1))
#+END_SRC
*** Navigate throught buffers
#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings)
#+END_SRC
*** Blindly follow symlinks without asking me
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks nil)
#+END_SRC
*** Auto refresh file if changed outside
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

* GDB
** Debugging environment
#+BEGIN_SRC emacs-lisp
  (setq
   ;; use gdb-many-windows by default
   gdb-many-windows t

   ;; ?
   gdb-use-separate-io-buffer t

   ;; Non-nil means display source file containing the main routine at startup
   gdb-show-main t
   )
#+END_SRC
** Fix source file opens in the wrong window
#+BEGIN_SRC emacs-lisp
  ;; Toggle window dedication
  (defun tedi:toggle-window-dedicated ()
    "Toggle whether the current active window is dedicated or not"
    (interactive)
    (message
     (if (let (window (get-buffer-window (current-buffer)))
           (set-window-dedicated-p window
                                   (not (window-dedicated-p window))))
         "Window '%s' is dedicated"
       "Window '%s' is normal")
     (current-buffer)))

  ;; Sets up the windows to make the command window dedicated
  (advice-add 'gdb-setup-windows :after
              (lambda () (set-window-dedicated-p (selected-window) t)))

  ;; Prevent gdb from popping i/o window to the foreground on every output op
  (setq-default gdb-display-io-nopopup t)
#+END_SRC
** Quitting messes up the window configuration
How do you quit anyway? I think the correct way is just to run quit in the
command window. But no matter how you quit GUD always messes up whatever window
configuration you had before you opened it.

We can fix that by saving the window layout when we run M-x gdb by storing the
layout into a register in gud-mode-hook. The gud-sentinal function runs when
some event occurs on the inferior gdb process. We can hook that to restore the
window state when the process exits.
#+BEGIN_SRC emacs-lisp
  (defconst gud-window-register 123456)

  (defun gud-quit ()
    (interactive)
    (gud-basic-call "quit"))

  (add-hook 'gud-mode-hook
            (lambda ()
              (gud-tooltip-mode)
              (window-configuration-to-register gud-window-register)
              (local-set-key (kbd "C-c q") 'gud-quit)))

  (advice-add 'gud-sentinel :after
              (lambda (proc msg)
                (when (memq (process-status proc) '(signal exit))
                  (jump-to-register gud-window-register)
                  (bury-buffer))))
#+END_SRC
** Debugging keybindings
TODO: http://emacs.1067599.n8.nabble.com/Gud-keybindings-td328833.html
#+BEGIN_SRC emacs-lisp
  (require 'gud)

  (defun tedi:gud-toggle-breakpoint ()
    "Enable/disable breakpoint at the current line of source buffer."
    (interactive)
    (save-excursion
      (beginning-of-line)
      (let* ((bol (point))
             (ovl (overlay-get (car (overlays-in bol bol)) 'before-string))
             (bptno (get-text-property 0 'gdb-bptno ovl))
             (bpten (get-text-property 0 'gdb-enabled ovl)))
        (if bpten (gud-basic-call (format "-break-disable %s" bptno))
          (gud-basic-call (format "-break-enable %s" bptno))))))

  (add-hook 'prog-mode-hook
            (lambda ()
              (local-set-key [f1]    'gud-run)
              (local-set-key [f2]    'gud-cont)

              ;;(local-set-key [f3]    'gdb)

              (local-set-key [f5]    'gud-next)
              (local-set-key [f6]    'gud-step)
              (local-set-key [f7]    'gud-until)
              (local-set-key [f8]    'gud-cont)
              (local-set-key [f9]    'tedi:gud-toggle-breakpoint)
              ;;(local-set-key [f9]    'gud-break)
              )
            )
#+END_SRC
* Coding style
** C/C++ style is bsd( Allman )
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "bsd"
        c-basic-offset 8)
#+END_SRC
** Indentation is tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode t)
#+END_SRC
** Tab is 8 spaces
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 8)
#+END_SRC
* Indentation
** Automatically indent when pressing RET
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC
** Indent this buffer
#+BEGIN_SRC emacs-lisp
  (defun tedi:indent-c-buffer ()
    "Use astyle command to auto format c/c++ code."
    (interactive "r")
    (if (executable-find "astyle")
      (progn
        (setq cursorPosition (point))
        (shell-command-on-region
         (point-min) (point-max)
         (concat
          "astyle")
         (current-buffer) t
         (get-buffer-create "*Astyle Errors*") t)
        (goto-char cursorPosition))
      (message "Cannot find binary \"astyle\", please install first.")))
#+END_SRC
** Indent buffer before save
#+BEGIN_SRC emacs-lisp
(defun tedi:indent-before-save ()
    "Auto styling before saving."
    (interactive)
    (when (member major-mode '(cc-mode c++-mode c-mode))
      (tedi:indent-c-buffer)))

(add-hook 'c-mode-common-hook (lambda () (add-hook 'before-save-hook 'tedi:indent-before-save)))
#+END_SRC
* Packages
** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))
#+END_SRC
** Dashboard
#+BEGIN_SRC emacs-lisp
  (defun tedi:test ()
    (interactive)
    (if (version< emacs-version "25.3")
        (progn
          ;; Dashboard need emacs 25.3
          (use-package dashboard
            :ensure t
            :config
            (dashboard-setup-startup-hook)
            (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
            (setq dashboard-items '((recents  . 5)
                                    (projects . 5)))
            (setq dashboard-banner-logo-title "First, solve the problem. Then, write the code."))
          )
      )
    )
#+END_SRC
** Disable mouse
Disable the mouse only inside emacs. This is usefull in a laptop and as an exercise to not use the mouse at all.
#+BEGIN_SRC emacs-lisp
  (use-package disable-mouse
    :ensure t)
  (global-disable-mouse-mode)
#+END_SRC
** Which key
Brings up help on key combinations.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC
** Try
Let's you try packages without installing them.
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** nwim
Smart move when you browse in code.
#+BEGIN_SRC emacs-lisp
  (use-package mwim
    :bind
    ("C-a" . mwim-beginning-of-code-or-line)
    ("C-e" . mwim-end-of-code-or-line))
#+END_SRC
* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.
** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode 1))
#+END_SRC
** Let projectile call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC
* Modeline
The modeline is the heart of emacs, it offers information at all times, it's persistent
and verbose enough to gain a full understanding of modes and states you are in.

Due to the fact that we attempt to use emacs as a desktop environment replacement,
and external bar showing the time, the battery percentage and more system info would be great to have.
I have however abandoned polybar in favor of a heavily modified modeline, this offers me more space
on the screen and better integration.

One modeline-related setting that is missing and is instead placed at the bottom is =diminish=.
** Spaceline!
I may not use spacemacs, since I do not like evil-mode and find spacemacs incredibly bloated and slow,
however it would be stupid not to acknowledge the best parts about it, the theme and their modified powerline setup.

This enables spaceline, it looks better and works very well with my theme of choice.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
      (setq spaceline-buffer-encoding-abbrev-p nil)
      (setq spaceline-line-column-p nil)
      (setq spaceline-line-p nil)
      (setq powerline-default-separator (quote arrow))
      (spaceline-spacemacs-theme))
#+END_SRC
** No separator!
#+BEGIN_SRC emacs-lisp
  (setq powerline-default-separator nil)
#+END_SRC
** Cursor position
Show the current line and column for your cursor.
We are not going to have =relative-linum-mode= in every major mode, so this is useful.
#+BEGIN_SRC emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+END_SRC

** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.
*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC
*** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC
** Battery indicator
A package called =fancy-battery= will be used if we are in GUI emacs, otherwise the built in battery-mode will be used.
Fancy battery has very odd colors if used in the tty, hence us disabling it.
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
      (setq fancy-battery-show-percentage t)
      (setq battery-update-interval 15)
      (if window-system
        (fancy-battery-mode)
        (display-battery-mode)))
#+END_SRC
** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance
with power-hungry processes in ansi-term

symon can be toggled on and off with =Super + h=.
#+BEGIN_SRC emacs-lisp
  (use-package symon
    :ensure t
    :bind
    ("s-h" . symon-mode))
#+END_SRC
* Minor conveniences
Emacs is at it's best when it just does things for you, shows you the way, guides you so to speak.
This can be best achieved using a number of small extensions. While on their own they might not be particularly
impressive. Together they create a nice environment for you to work in.
** Subwords
Emacs treats camelCase strings as a single word by default, this changes said behaviour.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
** Electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")
                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC
** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC
** Rainbow
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight
it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
      (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
** Show parens
I forgot about that initially, it highlights matching parens when the cursor is just behind one of them.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
** Expand region
A pretty simple package, takes your cursor and semantically expands the region, so words, sentences, maybe the contents of some parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC
** Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom.
Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered.
You may not like it, thus disable it if you must, but it's pretty decent.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config
      (global-hungry-delete-mode))
#+END_SRC
** Zapping to char
A nifty little package that kills all text between your cursor and a selected character.
A lot more useful than you might think. If you wish to include the selected character in the killed region,
change =zzz-up-to-char= into =zzz-to-char=.
#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :ensure t
    :bind ("M-z" . zzz-up-to-char))
#+END_SRC
* Kill ring
There is a lot of customization to the kill ring, and while I have not used it much before,
I decided that it was time to change that.
** Maximum entries on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC
** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Tramp
#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh")
#+END_SRC
* The terminal
I have used urxvt for years, and I miss it sometimes, but ansi-term is enough for most of my tasks.
** Default shell should be bash
I don't know why this is a thing, but asking me what shell to launch every single
time I open a terminal makes me want to slap babies, this gets rid of it.
This goes without saying but you can replace bash with your shell of choice.
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
** Easy to remember keybinding
In loving memory of bspwm, Super + Enter opens a new terminal, old habits die hard.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC
* Programming
Minor, non-completion related settings and plugins for writing code.
** Helm-Gtags
#+BEGIN_SRC emacs-lisp
  (use-package helm-gtags
    :ensure t
    )

  ;; Enable helm-gtags-mode
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)
  (add-hook 'python-mode-hook 'helm-gtags-mode)

  ;; customize
  (custom-set-variables
   '(helm-gtags-path-style 'relative)
   '(helm-gtags-ignore-case t)
   '(helm-gtags-auto-update t))

  ;; key bindings
  (with-eval-after-load 'helm-gtags
    (define-key helm-gtags-mode-map (kbd "M-.")   'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-,")   'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "M-u")   'helm-gtags-update-tags)

    (define-key helm-gtags-mode-map (kbd "M-t")   'helm-gtags-find-tag)
    (define-key helm-gtags-mode-map (kbd "M-r")   'helm-gtags-find-rtag)
    (define-key helm-gtags-mode-map (kbd "M-s")   'helm-gtags-find-symbol)
    (define-key helm-gtags-mode-map (kbd "M-p")   'helm-gtags-parse-file)

    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
    )

  (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
#+END_SRC
** Compiling
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-,") 'compile)
(define-key global-map (kbd "C-.") 'recompile)
#+END_SRC
** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC
** company mode
I set the delay for company mode to kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters.

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 3))

  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC
** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= for a while I decided to drop it
in favor of =company=, and it turns out to have been a great decision.

Each category also has additional settings.
*** c/c++
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))
#+END_SRC
**** company
Requires libclang to be installed.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC
*** python
**** Interpreter version
#+BEGIN_SRC emacs-lisp
    (setq python-shell-interpreter "python3")
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC
**** company
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC
*** emacs-lisp
**** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC
**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC
*** lua
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'flycheck-mode)
#+END_SRC
**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'company-mode)

  (defun custom-lua-repl-bindings ()
    (local-set-key (kbd "C-c C-s") 'lua-show-process-buffer)
    (local-set-key (kbd "C-c C-h") 'lua-hide-process-buffer))

  (defun lua-mode-company-init ()
    (setq-local company-backends '((company-lua
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-lua
    :ensure t
    :config
      (require 'company)
      (setq lua-indent-level 4)
      (setq lua-indent-string-contents t)
      (add-hook 'lua-mode-hook 'custom-lua-repl-bindings)
      (add-hook 'lua-mode-hook 'lua-mode-company-init))
#+END_SRC
*** bash
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'flycheck-mode)
#+END_SRC
**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
* Org
One of the absolute greatest features of emacs is called "org-mode".
This very file has been written in org-mode, a lot of other configurations are written in org-mode, same goes for
academic papers, presentations, schedules, blogposts and guides.
Org-mode is one of the most complex things ever, lets make it a bit more usable with some basic configuration.

Those are all rather self-explanatory.
** Fix bugs
#+BEGIN_SRC emacs-lisp
  (define-obsolete-function-alias 'org-define-error 'define-error)
#+END_SRC
** Common settings

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (visual-line-mode 1)))
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c '") 'org-edit-src-code)
#+END_SRC

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
    (add-to-list 'org-structure-template-alist
                 '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
                 '("c" "#+BEGIN_SRC c\n?\n#+END_SRC")
                 )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'yas-minor-mode)
#+END_SRC
** Exporting options
One of the best things about org is the ability to export your file to many formats.
Here is how we add more of them!
*** Hugo
#+BEGIN_SRC emacs-lisp
  (use-package ox-hugo
    :ensure t
    :after ox)
#+END_SRC
*** latex
#+BEGIN_SRC emacs-lisp
  (when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
    (require 'xdvi-search))
#+END_SRC

*** Twitter Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :ensure t)
#+END_SRC

*** Reveal.js
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t)
  (require 'ox-reveal)
  (setq org-reveal-root "file:///home/tedi/.emacs.d/reveal.js-3.7.0/")
  (setq org-reveal-title-slide nil)
#+END_SRC
* Swiper
Counsel is a requirement for swiper. Swiper makes search easier.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t)

(use-package swiper
  :ensure try
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key "\C-s" 'swiper)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (global-set-key (kbd "<f6>") 'ivy-resume)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-load-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "C-c g") 'counsel-git)
    (global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    (global-set-key (kbd "C-x l") 'counsel-locate)
    (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)))
#+END_SRC
* Iedit
Edit multiple regions simultaneously
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t)
  (require 'iedit)
  ;;This is a bug in Mac but in linux works.(I do not need a fix)
  ;;(define-key global-map (kbd "C-c ;") 'iedit-mode)
#+END_SRC
* Avy
Navigation to any place inside the window
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind ("M-s" . avy-goto-char))
#+END_SRC
